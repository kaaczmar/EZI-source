\section{Propozycje udoskonaleń i spodziewane efekty}
Przedstawione algorytmy można przede wszystkim bardzo łatwo i skutecznie zrównoleglić na wiele wątków, co zdecydowanie wpłynie na czas obliczeń - więcej rozwiązań można przejrzeć w tym samym czasie, co daje probabilistycznie większe prawdopodobieństwo znalezienia optimum lub wartości zbliżonej do optimum aniżeli wersja jednowątkowa. Oczywiście uzyskany efekt jest zależny w tym wypadku od architektury komputera i nic nie da w przypadku jednoprocesorowego stanowiska obliczeniowego, ale w dzisiejszych czasach nie powinno to stanowić większego problemu.

Można by pokusić się o napisanie prostych funkcji uaktualniających wartość funkcji rozwiązania bez konieczność przeglądania całego rozwiązania, co na pewno umożliwiałoby zyskanie kilku cykli procesora na przeglądnięcie większej liczby rozwiązań. Jednak wydaje się, że uzyskany zysk czasowy nie byłby na tyle znaczący na ostateczne wyniki poszczególnych algorytmów (dotyczyłby algorytmu random, greedy oraz steepest w równym stopniu, więc końcowe wyniki byłyby tylko odpowiednio przeskalowane).

Wydaje się, że wybór języka programowania $C++$ był podyktowany m.in. szybkością działania kompilowanego kodu (brak kodu pośredniego, który jest wykonywany przez wirtualną maszynę, tylko kod natywny pod dany system operacyjny), jednak ponownie wydaje się, że ta kwestia ma równorzędny wpływ na uzyskane wyniki każdego z algorytmów.

Na koniec istotne wydaje się odpowiednie dobieranie punktu startowego dla algorytmów lokalnego przeszukiwania zgodnie z zasadą ''dobre rozwiązania powinny znajdować się stosunkowo blisko lepszych rozwiązań'', czyli odpalenie na początek heurystyki znajdującej właśnie dobre rozwiązanie, które będzie stanowiło podstawę do działania dla algorytmów przeszukiwania. Wówczas istnieje szansa, że trafimy na lepsze rozwiązanie z większym prawdopodobieństwem aniżeli startowanie z losowych rozwiązań (być może słabych jeśli chodzi o wartość). Wniosek ten jest prawdziwy/nieprawdziwy, co można zaobserwować w tabeli (ref do tabeli).